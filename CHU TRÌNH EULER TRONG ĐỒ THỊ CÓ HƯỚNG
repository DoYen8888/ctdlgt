#include <iostream>
#include <vector>
using namespace std;

// Ham DFS kiem tra lien thong
void dfs(int u, vector<vector<int>>& adj, vector<bool>& visited) {
    visited[u] = true;
    for (int v : adj[u]) {
        if (!visited[v]) dfs(v, adj, visited);
    }
}

// Ham kiem tra chu trinh Euler
bool hasEulerianCycle(int V, vector<pair<int, int>>& edges) {
    vector<vector<int>> adj(V + 1), revAdj(V + 1);
    vector<int> inDeg(V + 1, 0), outDeg(V + 1, 0);
    
    for (auto [u, v] : edges) {
        adj[u].push_back(v);
        revAdj[v].push_back(u);
        outDeg[u]++;
        inDeg[v]++;
    }
    
    // Dieu kien 1: Moi dinh co inDeg == outDeg
    for (int i = 1; i <= V; i++) {
        if (inDeg[i] != outDeg[i]) return false;
    }
    
    // Dieu kien 2: Do thi lien thong manh
    vector<bool> visited(V + 1, false);
    int start = 1;
    while (start <= V && adj[start].empty()) start++;
    if (start > V) return true;
    
    dfs(start, adj, visited);
    for (int i = 1; i <= V; i++) {
        if (!adj[i].empty() && !visited[i]) return false;
    }
    
    fill(visited.begin(), visited.end(), false);
    dfs(start, revAdj, visited);
    for (int i = 1; i <= V; i++) {
        if (!revAdj[i].empty() && !visited[i]) return false;
    }
    
    return true;
}

int main() {
    int T, V, E;
    cin >> T;
    while (T--) {
        cin >> V >> E;
        vector<pair<int, int>> edges(E);
        for (auto& [u, v] : edges) cin >> u >> v;
        cout << (hasEulerianCycle(V, edges) ? 1 : 0) << endl;
    }
    return 0;
}
